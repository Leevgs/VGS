/**
 * NOTE: This is a serverless function endpoint.
 * It is designed to be deployed on a platform that supports serverless functions,
 * such as Vercel or Netlify. It will not work on a standard static web host.
 *
 * This file should be placed in a directory named `api` at the root of your project.
 * For example: `/api/generate-digest.ts`
 */
import { GoogleGenAI, Type } from "@google/genai";
import { type Digest, type DigestData } from '../types';

// This is a minimal request/response interface.
// Actual objects will be provided by the hosting platform (e.g., Vercel, Netlify).
interface ApiRequest {
    method?: string;
    query: {
        [key: string]: string | string[] | undefined;
    };
}
interface ApiResponse {
    status: (code: number) => ApiResponse;
    json: (body: any) => void;
    send: (body: string) => void;
    setHeader: (name: string, value: string) => void;
}

// --- DUPLICATED LOGIC FROM geminiService.ts ---
// In a real-world scenario with a shared codebase, you would import this.
// But to keep this self-contained and free of complex module resolution issues
// in different environments, we are duplicating the core logic here.

const formatDigestToHtml = (data: DigestData, digest: Digest): string => {
    const today = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
    const scheduleLabel = digest.schedule.charAt(0).toUpperCase() + digest.schedule.slice(1);

    const articlesHtml = data.digest?.map(topicDigest => {
        const articlesForTopic = topicDigest.articles?.map(article => `
            <div style="margin-bottom: 24px; padding: 16px; background-color: #ffffff; border-radius: 8px; border: 1px solid #e2e8f0;">
                <h3 style="margin-top: 0; margin-bottom: 8px; font-size: 18px; color: #1e293b; font-weight: 600;">${article.title}</h3>
                <p style="margin-top: 0; margin-bottom: 12px; color: #475569; font-size: 14px; line-height: 1.6;">${article.summary.replace(/\n/g, '<br>')}</p>
                <a href="${article.url}" target="_blank" style="display: inline-block; padding: 8px 16px; background: linear-gradient(to right, #4f46e5, #7c3aed); color: #ffffff; text-decoration: none; border-radius: 6px; font-size: 14px; font-weight: 500;">Read Full Story</a>
            </div>
        `).join('') || '';

        return `
            <h2 style="font-size: 22px; color: #334155; border-bottom: 2px solid #cbd5e1; padding-bottom: 8px; margin-top: 28px; margin-bottom: 20px;">${topicDigest.topicName}</h2>
            ${articlesForTopic}
        `;
    }).join('') || `<p>We couldn't find any news for your topics today.</p>`;

    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
            body { font-family: 'Inter', sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; background-color: #f1f5f9; }
            .container { max-width: 680px; margin: auto; padding: 20px; }
            .header {
                padding: 24px;
                margin-bottom: 24px;
                background: linear-gradient(to right, #1e293b, #334155);
                color: #ffffff;
                border-radius: 12px;
            }
            .header h1 { margin: 0; font-size: 28px; }
            .header p { margin: 4px 0 0; color: #cbd5e1; }
            .footer { margin-top: 32px; font-size: 12px; color: #64748b; text-align: center; }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>Your ${scheduleLabel} News Digest: ${digest.name}</h1>
                <p>${today}</p>
            </div>
            ${articlesHtml}
            <div class="footer">
                <p>Generated by News Digest AI</p>
            </div>
        </div>
    </body>
    </html>`;
};

const generateNewsDigestForWebhook = async (digest: Digest, apiKey: string): Promise<string> => {
    if (!apiKey) {
        throw new Error("API_KEY environment variable is not set on the server.");
    }
     const ai = new GoogleGenAI({ apiKey });

    if (digest.topics.length === 0) {
        throw new Error("Cannot generate digest: no topics provided.");
    }

    const prompt = `
        Act as a news aggregator. Your sole source for news is Google News.
        For each topic provided, find the most relevant articles.
        Return the title, a detailed, multi-paragraph summary of the article's content, and the direct source URL for each article. The summary for each article must be detailed, comprehensive, and between 300 and 500 words.

        Topics: ${digest.topics.join(', ')}
        Number of stories per topic: ${digest.storyCount}

        IMPORTANT: Structure the output as a single JSON object.
        The root object must have a key "digest" which is an array of topics.
        Each object in the "digest" array should contain:
        1. "topicName" (string): The name of the topic.
        2. "articles" (array of objects): A list of the articles for that topic.
        Each article object must contain:
        1. "title" (string)
        2. "summary" (string): A detailed, comprehensive summary between 300 and 500 words.
        3. "url" (string): The final direct URL, not a redirect from Google News.
    `;

    const responseSchema = {
        type: Type.OBJECT,
        properties: {
            digest: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        topicName: { type: Type.STRING },
                        articles: {
                            type: Type.ARRAY,
                            items: {
                                type: Type.OBJECT,
                                properties: {
                                    title: { type: Type.STRING },
                                    summary: { type: Type.STRING },
                                    url: { type: Type.STRING },
                                },
                                required: ["title", "summary", "url"],
                            },
                        },
                    },
                    required: ["topicName", "articles"],
                },
            },
        },
        required: ["digest"],
    };

    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: prompt,
        config: {
            responseMimeType: "application/json",
            responseSchema: responseSchema,
        }
    });
    
    const jsonText = response.text.trim();
    const data: DigestData = JSON.parse(jsonText);

    if (!data.digest || !Array.isArray(data.digest)) {
        throw new Error("The AI returned an invalid or empty digest.");
    }

    return formatDigestToHtml(data, digest);
};

// --- END OF DUPLICATED LOGIC ---


const getDigestConfig = (data: string): Digest | null => {
  try {
    const jsonString = Buffer.from(data, 'base64').toString('utf-8');
    return JSON.parse(jsonString) as Digest;
  } catch (e) {
    return null;
  }
};

const handler = async (req: ApiRequest, res: ApiResponse) => {
  if (req.method !== 'GET' && req.method !== 'POST') { // Allow POST for some services
    res.setHeader('Allow', 'GET, POST');
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  const { secret, data } = req.query;

  const expectedSecret = process.env.WEBHOOK_SECRET;
  if (!expectedSecret) {
    return res.status(500).json({ error: 'Internal Server Error: WEBHOOK_SECRET is not configured on the server.' });
  }
  if (secret !== expectedSecret) {
    return res.status(401).json({ error: 'Unauthorized: Invalid secret key.' });
  }

  if (!data || typeof data !== 'string') {
    return res.status(400).json({ error: 'Bad Request: Missing or invalid data parameter.' });
  }
  
  const digestConfig = getDigestConfig(data);
  if (!digestConfig) {
    return res.status(400).json({ error: 'Bad Request: Could not parse digest configuration.' });
  }

  try {
    const apiKey = process.env.API_KEY;
    if (!apiKey) {
        throw new Error("API_KEY is not configured on the server.");
    }
    const htmlContent = await generateNewsDigestForWebhook(digestConfig, apiKey);
    
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    return res.status(200).send(htmlContent);

  } catch (error) {
    console.error('Error generating digest via webhook:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return res.status(500).json({ error: 'Failed to generate news digest from AI.', details: errorMessage });
  }
};

// This default export is what platforms like Vercel and Netlify look for.
export default handler;